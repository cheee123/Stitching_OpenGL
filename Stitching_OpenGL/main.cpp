#include <stdio.h>
#include <stdlib.h>
#include <iostream>

#include <GLES3/gl31.h>
#include <GLFW/glfw3.h>
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>
#include <glm/gtx/rotate_vector.hpp>
#include <glm/gtx/vector_angle.hpp>
#include "opencv2/imgcodecs.hpp"
#include "opencv2/imgproc/imgproc.hpp"
#include "opencv2/highgui.hpp"

#include "Texture.h"
#include "shaderClass.h"
#include "VAO.h"
#include "VBO.h"
#include "EBO.h"
#include "Camera.h"

const unsigned int width = 1200;
const unsigned int height = 300;

int main()
{	
	GLfloat vertices[] = {
	//  ---- Position ----  -TexCoord -
		2.0f,  0.5f,  0.0f, 1.0f, 1.0f,  // UR
		2.0f,  -0.5f, 0.0f, 1.0f, 0.0f,  // BR
		-2.0f, -0.5f, 0.0f, 0.0f, 0.0f,  // BL
		-2.0f, 0.5f,  0.0f, 0.0f, 1.0f   // UL
	};
	GLuint  indices[] = {
		3,0,2,
		2,0,1
	};
	// Initialize glfw
	glfwInit();
	glfwWindowHint(GLFW_CLIENT_API, GLFW_OPENGL_ES_API);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 1);
	GLFWwindow* window = glfwCreateWindow(width, height, "Stitching_OpenGL", NULL, NULL);
	if (window == NULL)
	{
		std::cout << "Failed to create GLFW window" << std::endl;
		glfwTerminate();
		return -1;
	}
	glfwMakeContextCurrent(window);
	printf("GL_VERSION  : %s\n", glGetString(GL_VERSION) );
	printf("GL_RENDERER : %s\n", glGetString(GL_RENDERER) );
	glViewport(0, 0, width, height);
	glEnable(GL_DEPTH_TEST);

	// Initialize OpenGL features
	Shader shaderProgram("./resources/stitching.vert", "./resources/stitching.frag");
	VAO VAO0;
	VAO0.Bind();
	VBO VBO0(vertices, sizeof(vertices));
	EBO EBO0(indices, sizeof(indices));
	VAO0.Bind();
	VAO0.LinkAttrib(VBO0, 0, 3, GL_FLOAT, 5 * sizeof(float), (void*)0);
	VAO0.LinkAttrib(VBO0, 1, 2, GL_FLOAT, 5 * sizeof(float), (void*)(3 * sizeof(float)));
	VAO0.Unbind();
	VBO0.Unbind();
	EBO0.Unbind();
	Camera camera(width, height, glm::vec3(0.0f, 0.0f, 0.5f));

	// Initialize Textures
	Texture brickTex0("./resources/field0.jpg", "GL_TEXTURE_2D", 0);
	brickTex0.texUnit(shaderProgram, "tex0");
	Texture brickTex1("./resources/field1.jpg", "GL_TEXTURE_2D", 1);
	brickTex1.texUnit(shaderProgram, "tex1");
	Texture brickTex2("./resources/field2.jpg", "GL_TEXTURE_2D", 2);
	brickTex2.texUnit(shaderProgram, "tex2");
	Texture brickTex3("./resources/field3.jpg", "GL_TEXTURE_2D", 3);
	brickTex3.texUnit(shaderProgram, "tex3");
	Texture brickTex4("./resources/field4.jpg", "GL_TEXTURE_2D", 4);
	brickTex4.texUnit(shaderProgram, "tex4");
	Texture brickTex5("./resources/field5.jpg", "GL_TEXTURE_2D", 5);
	brickTex5.texUnit(shaderProgram, "tex5");



	// Code generated by Python:

	////////////////////////////////
	////////// Paste here //////////
	////////////////////////////////

	glm::mat3 H_T30, H_T31, H_T32, H_T34, H_T35;
	H_T32[0][0] = 0.8770719944693558; H_T32[0][1] = -0.09040336004395946; H_T32[0][2] = -0.10236792372464448; 
	H_T32[1][0] = 0.08220906737725117; H_T32[1][1] = 0.9577547222239092; H_T32[1][2] = 0.026910149374235453; 
	H_T32[2][0] = 0.30350675007296024; H_T32[2][1] = 0.00936751761358354; H_T32[2][2] = 0.9661118972945008; 
	H_T31[0][0] = 0.6556507627549438; H_T31[0][1] = -0.18337244528348237; H_T31[0][2] = -0.22491341246583452; 
	H_T31[1][0] = 0.14094572964745272; H_T31[1][1] = 0.8587123544544948; H_T31[1][2] = 0.01233879989600086; 
	H_T31[2][0] = 0.60470129233443; H_T31[2][1] = 0.007131034869454223; H_T31[2][2] = 0.8553994673312549; 
	H_T30[0][0] = 0.3909094869695602; H_T30[0][1] = -0.25720245910296125; H_T30[0][2] = -0.2887997901770089; 
	H_T30[1][0] = 0.14850368835769354; H_T30[1][1] = 0.6925945671672543; H_T30[1][2] = -0.042769541634736806; 
	H_T30[2][0] = 0.8207544454586465; H_T30[2][1] = -0.010444052991869244; H_T30[2][2] = 0.7005988431160225; 
	H_T34[0][0] = 1.0948415017246418; H_T34[0][1] = 0.11079224912862078; H_T34[0][2] = 0.11848493313790413; 
	H_T34[1][0] = -0.08698100839493562; H_T34[1][1] = 1.053369203645852; H_T34[1][2] = 0.017629818964695322; 
	H_T34[2][0] = -0.45573947571291157; H_T34[2][1] = -0.08949845630619221; H_T34[2][2] = 0.9495749207270244; 
	H_T35[0][0] = 1.134051948834878; H_T35[0][1] = 0.19149763331440833; H_T35[0][2] = 0.22017071122209844; 
	H_T35[1][0] = -0.13864178962249227; H_T35[1][1] = 1.0948107370554525; H_T35[1][2] = 0.017767919716636698; 
	H_T35[2][0] = -0.768075893258232; H_T35[2][1] = -0.1782778992495211; H_T35[2][2] = 0.8801586464886888; 
	glUniformMatrix3fv(glGetUniformLocation(shaderProgram.ID, "H_T30"), 1, GL_FALSE, glm::value_ptr(H_T30));
	glUniformMatrix3fv(glGetUniformLocation(shaderProgram.ID, "H_T31"), 1, GL_FALSE, glm::value_ptr(H_T31));
	glUniformMatrix3fv(glGetUniformLocation(shaderProgram.ID, "H_T32"), 1, GL_FALSE, glm::value_ptr(H_T32));
	glUniformMatrix3fv(glGetUniformLocation(shaderProgram.ID, "H_T34"), 1, GL_FALSE, glm::value_ptr(H_T34));
	glUniformMatrix3fv(glGetUniformLocation(shaderProgram.ID, "H_T35"), 1, GL_FALSE, glm::value_ptr(H_T35));
	glUniform1f(glGetUniformLocation(shaderProgram.ID, "f"), 0.6676946806414795);
	glUniform1f(glGetUniformLocation(shaderProgram.ID, "border_ratio"), 0.05308641975308642); 

	float tl_y = 0.12304250559284116;
	float tl_x = 0.14305555555555555;
	float br_y = 0.9172259507829977;
	float br_x = 0.8027777777777778;

	////////////////////////////////
	////////////////////////////////
	////////////////////////////////


	// int mainerror = glGetError();
	// printf("mainrerror0: %d\n", mainerror);

	// Save stitching result 
	cv::Mat stitched_img(height, width, CV_8UC4);

	// Keeps track of the amount of frames in timeDiff
	double prevTime = 0.0;
	double crntTime = 0.0;
	double timeDiff;
	double readimagestime;
	unsigned int counter = 0;

	// Main while loop
	while (!glfwWindowShouldClose(window))
	{
		// Calculate FPS
		crntTime = glfwGetTime();
		timeDiff = crntTime - prevTime;
		counter++;
		if (timeDiff >= 2.0)
		{
			// Creates new title
			std::string FPS = std::to_string((1.0 / timeDiff) * counter);
			std::string ms = std::to_string((timeDiff / counter) * 1000);
			std::string newTitle = "Stitching_OpenGL " + FPS + "FPS / " + ms + "ms";
			glfwSetWindowTitle(window, newTitle.c_str());

			// Resets times and counter
			prevTime = crntTime;
			counter = 0;
		}

		// Read new images (for example)
		readimagestime = glfwGetTime();
		cv::Mat img0 = cv::imread("./resources/field0.jpg");
		cv::Mat img1 = cv::imread("./resources/field1.jpg");
		cv::Mat img2 = cv::imread("./resources/field2.jpg");
		cv::Mat img3 = cv::imread("./resources/field3.jpg");
		cv::Mat img4 = cv::imread("./resources/field4.jpg");
		cv::Mat img5 = cv::imread("./resources/field5.jpg");
		cv::Mat imgs[] = {img0,img1,img2,img3,img4,img5};
		for(int i=0;i<6;i++){
			cv::cvtColor(imgs[i], imgs[i], cv::COLOR_BGR2RGB);
		}
		readimagestime = glfwGetTime() - readimagestime;
		// printf("readimagestime: %f\n", readimagestime);

		// Update textures
		brickTex0.NewImage(imgs[0].data);
		brickTex1.NewImage(imgs[1].data);
		brickTex2.NewImage(imgs[2].data);
		brickTex3.NewImage(imgs[3].data);
		brickTex4.NewImage(imgs[4].data);
		brickTex5.NewImage(imgs[5].data);
		
		// Re-render
		glClearColor(0.07f, 0.13f, 0.17f, 1.0f);
		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

		shaderProgram.Activate();
		camera.Inputs(window);
		camera.Matrix(90.0f, 0.1f, 100.0f, shaderProgram, "camMatrix");
		brickTex0.Bind();
		brickTex1.Bind();
		brickTex2.Bind();
		brickTex3.Bind();
		brickTex4.Bind();
		brickTex5.Bind();
		VAO0.Bind();
		
		glDrawElements(GL_TRIANGLES, sizeof(indices) / sizeof(int), GL_UNSIGNED_INT, 0);
		
		// Read result
		glReadPixels(0, 0, width , height, GL_RGBA, GL_UNSIGNED_BYTE, stitched_img.data);
		
		glfwSwapBuffers(window);
		// Take care of all GLFW events
		glfwPollEvents();
	}

	// Crop and write stitched image
	cv::flip(stitched_img, stitched_img, 0);
	stitched_img = stitched_img(cv::Range(tl_y*height, br_y*height), cv::Range(tl_x*width, br_x*width));
	cv::cvtColor(stitched_img, stitched_img, cv::COLOR_BGR2RGB);
	cv::imwrite("./stitched_img.jpg", stitched_img);

	VAO0.Delete();
	VBO0.Delete();
	EBO0.Delete();
	brickTex0.Delete();
	brickTex1.Delete();
	brickTex2.Delete();
	brickTex3.Delete();
	brickTex4.Delete();
	brickTex5.Delete();
	shaderProgram.Delete();

	glfwDestroyWindow(window);
	glfwTerminate();
	return 0;
}
